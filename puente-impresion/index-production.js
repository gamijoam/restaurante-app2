// --- 1. IMPORTACIONES ---
require('dotenv').config({ path: './config.env' });
const { Client } = require('@stomp/stompjs');
const WebSocket = require('ws');
const ThermalPrinter = require('node-thermal-printer').printer;
const PrinterTypes = require('node-thermal-printer').types;

Object.assign(global, { WebSocket });

// --- 2. CONFIGURACI√ìN PARA PRODUCCI√ìN ---
const WEBSOCKET_URL = process.env.WEBSOCKET_URL || 'ws://localhost:8080/ws';
const MAX_RECONNECT_ATTEMPTS = 3;
const RECONNECT_DELAY = 5000;
const PRINT_TIMEOUT = 25000; // 25 segundos para producci√≥n
const HEALTH_CHECK_INTERVAL = 20000; // 20 segundos

console.log('-----------------------------------------');
console.log('--- PUENTE DE IMPRESI√ìN v4.0 (PRODUCCI√ìN) ---');
console.log('-----------------------------------------');
console.log(`WebSocket URL: ${WEBSOCKET_URL}`);
console.log(`Modo: PRODUCCI√ìN`);
console.log(`Timeout de impresi√≥n: ${PRINT_TIMEOUT/1000} segundos`);

// --- 3. VARIABLES DE CONTROL ---
let reconnectAttempts = 0;
let isConnected = false;
let currentPrintJob = null;
let printTimeout = null;
let healthCheckInterval = null;
let isShuttingDown = false;
let lastPrintTime = null;

// --- 4. FUNCI√ìN DE IMPRESI√ìN PARA PRODUCCI√ìN ---
async function imprimirTicket(printJob) {
    // Evitar trabajos simult√°neos
    if (currentPrintJob) {
        console.log('‚ö†Ô∏è Ya hay un trabajo de impresi√≥n en curso, ignorando...');
        return;
    }

    currentPrintJob = printJob;
    const { printerType, printerTarget, ticketType, ticketData } = printJob;
    
    console.log(`\nüñ®Ô∏è NUEVO TRABAJO DE IMPRESI√ìN (PRODUCCI√ìN):`);
    console.log(`   Tipo: ${printerType}`);
    console.log(`   Destino: ${printerTarget}`);
    console.log(`   Ticket: ${ticketType}`);
    console.log(`   Mesa: ${ticketData?.nombreMesa || 'N/A'}`);

    // Configurar timeout para producci√≥n
    printTimeout = setTimeout(() => {
        console.error('‚ùå Timeout de impresi√≥n alcanzado (25 segundos)');
        cleanupPrintJob();
    }, PRINT_TIMEOUT);

    try {
        // Validar datos b√°sicos
        if (!ticketData || !ticketData.nombreMesa || !ticketData.items) {
            console.error('‚ùå Datos del ticket incompletos');
            cleanupPrintJob();
            return;
        }

        // Crear impresora con configuraci√≥n para producci√≥n
        const printer = new ThermalPrinter({
            type: PrinterTypes.EPSON,
            interface: printerTarget,
            driver: require('node-printer'),
            characterSet: 'PC850_MULTILINGUAL',
            timeout: 8000 // 8 segundos timeout para producci√≥n
        });

        // Imprimir seg√∫n el tipo
        if (ticketType === "COCINA") {
            await imprimirTicketCocinaProduccion(printer, ticketData);
        } else {
            await imprimirTicketCajaProduccion(printer, ticketData);
        }
        
        await printer.execute();
        console.log("‚úÖ Ticket enviado exitosamente (PRODUCCI√ìN)");
        lastPrintTime = new Date();
        
    } catch (error) {
        console.error(`‚ùå Error de impresi√≥n en producci√≥n: ${error.message}`);
        console.error(`Stack trace: ${error.stack}`);
        
        // No intentar reconectar autom√°ticamente en producci√≥n
        cleanupPrintJob();
    }
}

// Funci√≥n para limpiar trabajo de impresi√≥n
function cleanupPrintJob() {
    if (printTimeout) {
        clearTimeout(printTimeout);
        printTimeout = null;
    }
    currentPrintJob = null;
}

// --- FUNCI√ìN PARA TICKETS DE COCINA (PRODUCCI√ìN) ---
async function imprimirTicketCocinaProduccion(printer, ticketData) {
    try {
        printer.alignCenter();
        printer.println("COCINA");
        printer.println("================================");
        printer.alignLeft();
        
        printer.println(`Mesa: ${ticketData.nombreMesa}`);
        printer.println(`Comanda: ${ticketData.comandaId || 'N/A'}`);
        printer.println(`Hora: ${new Date().toLocaleTimeString()}`);
        printer.println("--------------------------------");
        
        printer.println("Cant. | Producto");
        printer.println("--------------------------------");
        
        ticketData.items.forEach((item, index) => {
            const cantidad = (item.cantidad || 0).toString().padStart(3);
            const producto = (item.nombreProducto || "Producto").substring(0, 25);
            printer.println(`${cantidad} x ${producto}`);
            
            if (item.notas && item.notas.trim()) {
                printer.println(`     Nota: ${item.notas}`);
            }
        });
        
        printer.println("--------------------------------");
        printer.alignCenter();
        printer.println("¬°LISTO PARA PREPARAR!");
        printer.println("");
        printer.cut();
        
    } catch (error) {
        console.error('‚ùå Error en ticket cocina (producci√≥n):', error.message);
        throw error;
    }
}

// --- FUNCI√ìN PARA TICKETS DE CAJA (PRODUCCI√ìN) ---
async function imprimirTicketCajaProduccion(printer, ticketData) {
    try {
        printer.alignCenter();
        printer.println("Restaurante 'El Buen Sabor'");
        printer.println("================================");
        printer.alignLeft();
        
        printer.println(`Mesa: ${ticketData.nombreMesa}`);
        printer.println(`Comanda: ${ticketData.comandaId || 'N/A'}`);
        printer.println(`Fecha: ${new Date().toLocaleString()}`);
        printer.println("--------------------------------");
        
        printer.println("Cant. | Producto | Total");
        printer.println("--------------------------------");
        
        ticketData.items.forEach((item, index) => {
            const cantidad = (item.cantidad || 0).toString().padStart(3);
            const producto = (item.nombreProducto || "Producto").substring(0, 20).padEnd(20);
            const precio = item.precioTotal || 0;
            const total = `$${precio.toFixed(2)}`.padStart(8);
            printer.println(`${cantidad} | ${producto} | ${total}`);
        });
        
        printer.println("--------------------------------");
        printer.alignRight();
        const total = ticketData.total || 0;
        printer.println(`TOTAL: $${total.toFixed(2)}`);
        printer.alignCenter();
        printer.println("¬°Gracias por su visita!");
        printer.println("");
        printer.cut();
        
    } catch (error) {
        console.error('‚ùå Error en ticket caja (producci√≥n):', error.message);
        throw error;
    }
}

// --- 5. CLIENTE STOMP PARA PRODUCCI√ìN ---
const stompClient = new Client({
    brokerURL: WEBSOCKET_URL,
    reconnectDelay: RECONNECT_DELAY,
    heartbeatIncoming: 4000,
    heartbeatOutgoing: 4000
});

stompClient.onConnect = () => {
    console.log('‚úÖ WebSocket conectado (PRODUCCI√ìN)');
    isConnected = true;
    reconnectAttempts = 0;
    
    stompClient.subscribe('/topic/print-jobs', async (message) => {
        try {
            const printJob = JSON.parse(message.body);
            console.log('üì® Trabajo de impresi√≥n recibido (PRODUCCI√ìN)');
            await imprimirTicket(printJob);
        } catch (error) {
            console.error('‚ùå Error procesando mensaje (PRODUCCI√ìN):', error.message);
        }
    });
    
    console.log("‚úÖ Suscrito a '/topic/print-jobs' (PRODUCCI√ìN)");
};

stompClient.onDisconnect = () => {
    console.log('‚ùå WebSocket desconectado (PRODUCCI√ìN)');
    isConnected = false;
};

stompClient.onStompError = (frame) => {
    console.error('‚ùå Error STOMP (PRODUCCI√ìN):', frame.headers['message']);
    isConnected = false;
    
    // Reconexi√≥n limitada para producci√≥n
    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS && !isShuttingDown) {
        reconnectAttempts++;
        console.log(`üîÑ Reconexi√≥n ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} (PRODUCCI√ìN)`);
        setTimeout(() => {
            if (!isConnected && !isShuttingDown) {
                stompClient.activate();
            }
        }, RECONNECT_DELAY);
    }
};

stompClient.onWebSocketError = (error) => {
    console.error('‚ùå Error WebSocket (PRODUCCI√ìN):', error.message);
    isConnected = false;
    
    // Reconexi√≥n limitada para producci√≥n
    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS && !isShuttingDown) {
        reconnectAttempts++;
        console.log(`üîÑ Reconexi√≥n ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} (PRODUCCI√ìN)`);
        setTimeout(() => {
            if (!isConnected && !isShuttingDown) {
                stompClient.activate();
            }
        }, RECONNECT_DELAY);
    }
};

stompClient.onWebSocketClose = () => {
    console.log('‚ùå WebSocket cerrado (PRODUCCI√ìN)');
    isConnected = false;
};

// --- 6. FUNCI√ìN DE LIMPIEZA ---
function cleanup() {
    console.log('üßπ Limpiando recursos (PRODUCCI√ìN)...');
    isShuttingDown = true;
    
    cleanupPrintJob();
    
    if (healthCheckInterval) {
        clearInterval(healthCheckInterval);
        healthCheckInterval = null;
    }
}

// --- 7. INICIALIZACI√ìN ---
console.log('üîÑ Conectando al broker STOMP (PRODUCCI√ìN)...');
stompClient.activate();

// --- 8. HEALTH CHECK PARA PRODUCCI√ìN ---
healthCheckInterval = setInterval(() => {
    if (!isShuttingDown) {
        if (!isConnected && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
            console.log('‚ö†Ô∏è Desconectado, intentando reconectar (PRODUCCI√ìN)...');
            stompClient.activate();
        } else if (isConnected) {
            console.log('‚úÖ Sistema funcionando correctamente (PRODUCCI√ìN)');
            if (lastPrintTime) {
                console.log(`üìÖ √öltima impresi√≥n: ${lastPrintTime.toLocaleTimeString()}`);
            }
        }
    }
}, HEALTH_CHECK_INTERVAL);

// --- 9. MANEJO DE SE√ëALES ---
process.on('SIGINT', () => {
    console.log('\nüõë Cerrando puente de impresi√≥n (PRODUCCI√ìN)...');
    cleanup();
    setTimeout(() => {
        stompClient.deactivate();
        process.exit(0);
    }, 1000);
});

process.on('SIGTERM', () => {
    console.log('\nüõë Cerrando puente de impresi√≥n (PRODUCCI√ìN)...');
    cleanup();
    setTimeout(() => {
        stompClient.deactivate();
        process.exit(0);
    }, 1000);
});

// --- 10. MANEJO DE ERRORES ---
process.on('uncaughtException', (error) => {
    console.error('‚ùå Error no capturado (PRODUCCI√ìN):', error.message);
    console.error('Stack trace:', error.stack);
    cleanup();
});

process.on('unhandledRejection', (reason) => {
    console.error('‚ùå Promesa rechazada (PRODUCCI√ìN):', reason);
    cleanup();
});

console.log('üöÄ Puente de impresi√≥n iniciado correctamente (PRODUCCI√ìN)'); 